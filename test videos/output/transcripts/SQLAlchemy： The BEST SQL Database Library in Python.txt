 Sequel Alchemy, it sounds like it's some kind of weird library that combines sequel with questionable practices from the Middle Ages. But that's not true, it's really cool packets that combines the power of sequel with the flexibility of Python. It did get me thinking though, what would my job be if I was born in the Middle Ages? Since I'm Dutch, I would probably be a traitor. You know, go to the other side of the world, get all sorts of weird exotic spices, like nutmeg, or a doctor, which in the Middle Ages basically was somebody killing people for a living and giving the term organ player a whole different meaning. What would your job be in the Middle Ages? Let me know in the comments, or write it on a scroll and send it to me by pigeon. Anyway, if you like learning about libraries like sequel Alchemy and other cool packages, software design techniques, all things Python, check out my free newsletter. And join the link below. Sequel Alchemy is a really powerful and flexible library for working with databases in Python, as this allows you to map database roles and tables to objects in Python. And this kind of tool is also called an object relational map or an ORM. Sequel Alchemy has lots of tools for working with database and can work with various types of sequel databases such as sequel light, my sequel and post-cress well. So do today show you the basics of how works, but then also show you a couple of more advanced things that you can do with sequel Alchemy. So start with this very first more functional approach of using sequel Alchemy. So without relying on its class system to map tables to classes. So if you're using this approach, then you're simply using the build in objects and functions of sequel Alchemy. The first thing that you need to do is create a connection to the database and that involves a couple of lines of code. In this case, I'm using sequel Alchemy in memory database on modern actual database, but you can replace this with any database connection string if you have a database running in the cloud, for example. So we first create the database engine and then we create a connection. Now of course, normally this is not something you're going to do very often. This will be hidden somewhere in your code and then you just work with the connection in all the other places, but it's still important that you do that. Of course, otherwise, there's no way to interact with the database. Another thing that you need to do is create a meta data object. This allows you to define a schema basically the structure of your database. And then the next thing that you do is create the actual schema of your database. So this case, we have a single table called user and that table has three columns, an ID, which is an integer. It's also a primary key and we have a username, which is a string and an email address, which is also a string. That's it, single table. If you want to create more tables, you simply add more of these table objects and then specify the columns that you need. Then once you have this table object, you can write functions that interact with it. For example, here I have an insert user function that gets a username and an email and that uses the insert function, insert method on the table and provides values to username and email address and then executes that particular query. So you construct a query and then you execute it using the connection that we defined right here. Similarly, you can also have a select user. So we have a username that we pass as an argument and we return a result. Just like the insert operation, we create the query, which is a select query and we provide a condition, which is that the username in the table is the same as the username that we passed as an argument. We retrieve the result back, using the query and then we fetch one of the results and that's going to give us the user. Then in the main function we call create. Oh, we supply the engines. So this is going to create the tables that are necessary and then we can call the functions that we define. Insert user, select user. So when I run this, then this is what we get. We get one user that's been inserted with ID1 and this is what's being shown when I print that particular user. You can also tell SQL Alchemy to print a bit more details about what it's actually doing by setting a code to true when you create the engine like so. Now when I run this code again, you see that we get more details. So the first thing that it does is create a table, which has an ID integer username and an email and ID is a primary key. And then you can also see what, for example, the insert operation looks like or what the select operation looks like. So this is really helpful for debugging. So you can then analyze the queries and see whether you're really querying the database in a way that you want to. Now this is a very simple basic way of using SQL Alchemy, but this will typically not be how you use it because SQL Alchemy has very powerful mechanisms to tie into Python's object oriented programming to allow for a lot more flexible. And so here you see another version of this exact same example we have a single user table, but now I'm using an object oriented approach. So the way that this works is that well, we still need to create the database engine because that's underlying everything. But then we create a session using the session maker function that binds the database to the session. And then we create a base and this is the base class that you will use to define actual tables. And in the main function, you see that base has metadata. So that's the object that manages the schema for us. And there we pass the database in order to create the actual schema. So we use the base object. But now that we have this, we can define classes that inherit from base. So here, for example, we have a user class that inherits base. We supply a table name with a donor instance variable called so the tables called users. And then we use a data classes like mechanism of defining the column. So instead of having to call the column functions, we can simply use the types, which is a really neat feature of SQL Alchemy. And in order to specify the types of the columns, we use the mapped type. So I did map integer username and email are mapped strings. And then you can call optionally the mapped column function to supply extra information about what kind of column this is. And then this is the ID column should be a primary key. So that's what we pass here. But you can, for example, also indicate that this is an index and that it should be unique. So mapped column basically allows you to specify any type of thing you would normally specify in SQL when you define what the column is supposed to be like. But the nice thing is is now that we have classes for each table, we can add methods to it. For example, here I've defined the wrapper method, which gives us a developer friendly representation of the object. In this case, that's user with an ID username and email address. And if you wanted to, you can add more methods to the user table here that work with this particular data that's part of each row. And the way that you work with data now is very simple. So we can simply create an instance of the user class that we just defined here. And then we can use a session to actually interact with the database. So we use the session class that's been generated by session maker. And then we create a session instance that we can then use. So in this case, we add the user to the database and then we commit that. And of course, here I'm just adding a single user, but you can add as many users as you want and then commit that result. And once you have that, there's also easy mechanisms to query the database. For example, here I'm querying the user table. And I simply want to get all users. And then that's going to print all the users that are currently in the database. So when I run this particular example, we see that we now get the single user that we just added. But let's say we want to add another user. Let's not call that user are on but something else. Like so. And now we can also add the second user. So on this again, and now you see we get R2 users as expected. So it's very, very simple to use. And what I like in particular about this that this allows me to abstract away from very database specific things like SQL queries, which is sometimes a bit hard to read. And this really simplifies things a lot. So this covers the object part of over how about relationships. Here I have another version of the user table, but I've added a bit of complication here. So we don't just have a user name and email address. We now have next to the ID. We have an off object and we have a posts object. So user has a user off. What that is, I'll show you in a minute. And it also has posts. And as you can see, a major difference here is that off is not a mapped column, but it's a relationship. And it's a relationship between user and user off, which is defined below, which is also a table in the database. And this is what we call a one to one relationship. One user has exactly one user off. There's also post, which is a mad list of us opposed. So that's a one to many relationship. A user can have many posts. And then user off contains information related to specific authentication method. In this case, that's a hashed password. Now, this is of course a very basic authentication example. And you wouldn't typically develop off this yourself from scratch, especially if using, for example, something like fast API, it's going to have already things like authentication or all of flows implemented. So you can use those as a starting point. But of course, you still need to store authentication data in the database. Now, next to authentication, another thing you might want to do if you're building more complex products, especially for businesses, is to have some sort of authorization. In other words, what is a particular user allowed to do? So authentication is identifying who it is. Authorization is determining what you're allowed to do. Authorization, by the way, is complete pain to build yourself if you can avoid doing that and use an out-of-the-box solution, like also the sponsor of today's video. Also, it makes it easy for developers to build fine grain, custom roles and permissions into your applications. It uses a special language for that called polar. Polar has out-of-the-box primitive support, access control mechanisms like RBAC, ReBAC and A-BAC. Along with the flexibility to extend those permissions as your applications involve. It's really nice to have authorization taken care of for you because access control is one of the more common things that you can see in the OAS top 10 risk-related security incidents. Also, it allows you to treat your permissions code exactly like the rest of your application, including longing testing auditing tools for compliance. You get comprehensive logs, metrics and real-time tracking of access control decisions and activities. You can access also cloud-fear RESTful API and there are as the case available, including for Python. For example, here in my authentication example that I showed you before, you can simply import also from the OAS package after you've installed that. Then you create the OAS object you passed there, URL and you provide your API key, which I haven't done in this particular example. You get an API key, you just put it in here, you read it from a dot-end file, and then you can use the also object to provide information. For example, here a user with ID Bob has a particular role in this case, the owner role. And then once you have that set up, so this you can link, for example, with your database. And then in your application code, it's really easy to authorize users for particular actions. For example, here I'm checking that Bob is authorized to write our own codes. If Bob is, then I can create users and do whatever I want to do. Otherwise, in this case, I print a message, but of course you can also, if this is part of an API, for example, raise an HTTP error that the user doesn't have the authority to do this. Get started for free with also cloud today using the link below. I've also put in the description of this video. Let's take a closer look at some of these relationships. The relationship between user and user off, which is the one-to-one relationship. And you can see that because we indicated that this doesn't use a list, so it's really mapping to a single object. Also, you see that there is a backpopulate option. What backpopulate does is that it syncs the relationships between the different tables. In this case, user and user off. So you see that we have a backpopulate here, but we also have it in user off, where it's part of the user relationship. So these types of relationships are typically two-way. And same for the posts, you see that we have a backpopulate user here, but on the post side, so that's user-post, we also have a user that backpopulates to the post. So again, that syncs the relationship between these two tables. There's also a couple of other things that you see here. For example, a user post has a user ID, so that's an ID of a user. The user that basically is the owner of this post. And in SQL, this type of relationship is represented using a foreign key. So user ID refers to an ID of a user row. And that's what we specify here as well. And you can also define other things here. For example, we always want user IDs to have value, so it's not notable. It's also an index so you can find all the posts by a user of a given ID, and so on. So you can really use all of these standard SQL options that you are used to in SQL Alchemy. And there's even more advanced things that you can do. For example, you can also specify a cascade attribute that defines what should happen if, for example, the parent of an object is deleted. So you can set that so that SQL Alchemy will automatically also delete the child object. So for example, if you delete the user, you may also want to delete all the posts created by that user. And there's different options here of how you want that behavior to work exactly. I really recommend you check out the documentation to see all the options because it's quite extended. But you do have those possibilities in SQL Alchemy. If you look at the main function in this example, you see that I use several session context managers to interact with the database. Using these context managers actually really helpful because then we don't forget to commit or rollback our changes. Here you see we create a user which has a username, email and a password. And what happens in the initializer of the user is that this then creates the user off object for us. And then because user off is a class we're using an Orem, we can call methods on it. So here we set the password. And if you look at what this method actually does is that it creates a hash for you. So that's one of the nice things about using Orems that you can add behavior to your tables, which is normally not available in SQL obviously because that's not object oriented. And same thing we can add other methods as well, such as for example checking the password. So if you look again at the main function, you see that we get the user, we print the user off object, we print the posts belong to this user, and then we can do a password check by calling the check password method. Of course the first one is the correct password, really bad password never use password as your password. And if we check the wrong password then this is going to return false. And finally you can also print the posts by this user. And because all of these things are separate tables, we have a user's table, an auth table and a post table. You can also query user posts directly and then simply filter it by a particular user. So when I run this code then this is what we get. So it prints the user, prints the user off object, it prints the posts by the particular user. The first password check is through, second one is false, and then we get the post by doing a simple SQL query. There's a lot more that's possible with SQL Alchemy, I really just scratched the surface in this video. But I do hope that it gave you an idea of what you can do with SQL Alchemy. But I'd like to hear from you. Do you use SQL Alchemy? Or do you prefer to just write the SQL statements yourself? Let me know in the comments below. If you enjoyed this video you might also like this video where to talk about the difference between using raw SQL statements versus a SQL query builder versus an O-RAM like SQL Alchemy. Thanks so much for watching and see you in the next one.