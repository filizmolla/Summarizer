 When chatting with someone on Jupiter's third largest moon, you will notice a distinct lag in communications. That is due to Async I-O. When you try to perform a task that requires a lot of waiting, you may notice an annoying lag in execution. You can solve this with Async I-O. This module brings the await and Async syntax to Python. This pair of five letter words empowers you with the tools to easily manage a collection of laggy tasks. Sometimes impatience is a virtue. Code can be categorized as synchronous or asynchronous. In synchronous programming, tasks are performed one at a time in the order they are called. Each task must finish before the next one can begin. With Async programming, however, different tasks can start, process, and finish in overlapping periods of time. For example, imagine a task that submits many HTTP requests. In the synchronous world, these HTTP requests must be completed one at a time. In the Async world, each request can start and be set aside while waiting for a response. During this waiting period, different tasks can step forward and use the computing resources. This non-linear approach saves one of the most valuable resources around. Time To better understand the mechanics of synchronous and asynchronous execution, you need to learn about subroutines and co-routines. A subroutine is a block of code that can be called as needed. When a subroutine is called, control of the program is transferred to that subroutine. When its work is done, control is returned back to the main program and execution continues from where it left off. Subroutines cannot be paused and resumed. They run until done. A co-routine is a special kind of function that can have its executions paused and resumed. This is possible because they maintain their state between pauses. Subroutines are perfect for tasks that need to wait for something. Like IO operations, database calls, and HTTP requests, the terms subroutine and co-routine are derived from the roles they play and how they function. Subroutine is a delightful blend of sub and routine. As the name suggests, it is a subset of a larger program. Subroutine is a juxtaposition of co and routine, co for together and routine for routine. This name was chosen by someone to describe routines that can run cooperatively. Co-routines are the key ingredient to make asynchronous programming or concurrency possible. In a typical single threaded app, all of the code in subroutines runs sequentially. This is simple but can be wasteful. There are two different approaches that make better use of available computing resources, concurrency and parallelism. Using concurrency, the start and stop times of multiple co-routines can overlap. With parallelism, different threads can execute at the same time. Is there going to be any Python in this Python lesson? Yes. Yes, there is. But before we can enter Python mode, I must import an important message. Socratica is now in the course business. Visit Socratica.com to see the excitement for yourself. And for an asynchronous update about future courses, feverishly type your email address in a text box somewhere on the site. Now back to Python. We are now going to show you how to use concurrency in Python with the async and await keywords and the async I.O module. Let us create two functions, brew coffee and toast bagel. The brew coffee function will use the sleep function to simulate a command that takes three seconds to complete. The toast bagel function will pretend it takes two seconds to complete. With this five second toasty breakfast, the future is fast and carbolicious. We will record a start time, call both functions, record a stop time, compute the elapsed time and print the results. Run. This code took five seconds and a bit more to execute. Now there is no reason to wait for the coffee to finish before you start toasting the bagel. Such inefficiency gives the secretly embedded AI systems far too much time for mischief. Let us modify this code so it runs concurrently with co-routines. To turn each function into a co-routine, add the async keyword. This is the first step, but not the last. As is evident if you run. Run the async keyword to make a co-routine is necessary, but not sufficient. You also need to specify where in the co-routine it is safe to pause and yield control to other co-routines. You do this with the await keyword. This brings us to another essential concept. You can only put await in front of commands that are awaitable. The sleep function is not awaitable. Luckily, the async IO module gives you an awaitable version of the sleep function. You can call the co-routines individually or in a batch. We will first demonstrate the batch approach. The async IO module has a gather function to group co-routines for concurrent execution. The arguments determine which co-routines will run concurrently. The arguments may appear to be regular function calls, but they are not. Calling a co-routine returns a co-routine object, not a typical return value. These co-routine objects give async IO the ability to start and stop their execution. To get the return values from the co-routines, you need to await them. And note that you await the return values in the same order you pass the co-routines to the gather function. Order matters. And the use of a weight here is not optional. After all, we have to wait for both co-routines to finish. So it only makes sense that we have to wait on the batch too. We are so close to the finish line, but there is one final step. See how we await for the batch results. Any function that has an await keyword must be declared async. This means we must put the async keyword before the main function. Because main has now become a co-routine, we have to call it in a slightly different way. The async IO module has you covered. Just call the run function and pass in the main co-routine. Now inhale, widen your eyes, and run. Joy of joys. Our breakfast was completed in three seconds instead of five. Time saved. Me, happy. There is an alternative to using the gather function. You can use the create task function in the async IO module to create a task out of each co-routine. Then you can await each co-routine individually. Run. Just as fast. Just as happy. So which is better? Working in batches or with individual tasks? It is your choice. So choose wisely. Computer chips want to compute. That is their singular purpose in life. The async IO module was built to help chips realize their full potential. By adding a pause button to objects, you enable them to take turns. Sharing is caring after all. And speaking of sharing, many human people ask you to share their videos with as many human people as possible. This is not an efficient use of resources. Instead, await the opportunity to yield this video to someone who has finished a task and is thinking about the future.