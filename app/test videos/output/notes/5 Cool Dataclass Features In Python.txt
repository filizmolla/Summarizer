**5 Cool Dataclass Features in Python**

**Feature 1: Easy Creation and Automatic Initialization**
- Create a dataclass using the `@dataclass` decorator:
  ```python
  @dataclass
  class Person:
      name: str
      age: int
      friends: list[str]
  ```
- Create an instance with attributes set directly:
  ```python
  person = Person(name="Bob", age=29, friends=["Luigi", "James"])
  ```
- Print the instance to get a readable representation:
  ```python
  print(person)  # Output: Person(name='Bob', age=29, friends=['Luigi', 'James'])
  ```

**Feature 2: Readable String Representation**
- Data classes provide a default string representation that includes the class name and attributes.
- For a normal class, a complex string representation is needed:
  ```python
  class Person:
      def __init__(self, name, age, friends):
          self.name = name
          self.age = age
          self.friends = friends

  person = Person(name="Bob", age=29, friends=["Luigi", "James"])

  # Define a custom string representation
  def __str__(self):
      return f"Person(name={self.name}, age={self.age}, friends={self.friends})"
  ```

**Feature 3: Easy Ordering**
- Set `order=True` in the dataclass decorator to enable ordering:
  ```python
  @dataclass(order=True)
  class Person:
      name: str
      age: int
      friends: list[str]
  ```
- Compare objects using the `>` and `<` operators:
  ```python
  person1 = Person(name="Bob", age=29, friends=["Luigi", "James"])
  person2 = Person(name="James", age=25, friends=["Bob", "Luigi"])

  print(person1 > person2)  # False
  print(person1 == person2)  # False
  ```

**Feature 4: Immutability**
- Set `frozen=True` in the dataclass decorator to make the object immutable:
  ```python
  @dataclass(immutable=True)
  class Person:
      name: str
      age: int
      friends: list[str]
  ```
- Attempts to change attributes will result in an error:
  ```python
  person = Person(name="Bob", age=29, friends=["Luigi", "James"])

  try:
      person.age = 30
  except frozeninstanceError:
      print("Cannot change attributes of frozen dataclass")
  ```

**Feature 5: Computed Properties**
- Use the `@property` decorator to define computed properties:
  ```python
  @dataclass
  class Rectangle:
      width: float
      height: float

  @property
  def area(self) -> float:
      return self.width * self.height

  @property
  def perimeter(self) -> float:
      return 2 * (self.width + self.height)
  ```
- Access computed properties using dot notation:
  ```python
  rectangle = Rectangle(width=10, height=20)

  print(rectangle.area)  # 200
  print(rectangle.perimeter)  # 60
  ```