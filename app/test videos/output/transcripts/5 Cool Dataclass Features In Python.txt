 This video was brought to you by IndentelyIO. Learning Python made simple. How's it going everyone? In today's video, I'm going to be covering five features that I really appreciate about data classes. And these are also five features I find really cool. Starting with the first feature, how easy it is to create a data class and that it covers the initializer automatically. And to show you what I mean, let's get started by creating our very first data class. And to do so, we need to import from data classes the data class. Then we can use the add data class decorator and we can create our class, which in this example is going to be a person. And this person will have a name of type string, an age of type integer and some friends, hopefully, of type list of string. And that's all that this class will contain. And next we can create an instance. So we're going to call this instance Bob of type person, which will equal a person with the name set to Bob, the age set to 29. And his friends will be Luigi and James. Now when we print this person, what you should notice is that we will get back a person object that contains this data. And essentially what that means is that every time we create an object like this, we can refer to its attributes by using dot notation. But now it's time we look at the equivalent with a normal class. So here we can create another class called person. It's going to take an initializer, which will of course require self, a name of type string, an age of type integer, and a friends of type list of string. And I need to zoom out and this will return none. Then self dot name will equal name, self dot age is going to equal age and self dot friends is going to equal friends. Then we can do the exact same thing, create an instance called Bob and print it. Now when we run this, you're going to notice we're not even going to get this lovely representation back. We're going to get the memory edges of the person object back. So not only did we have to write all of this extra code, but we don't even get a nice representation back, which brings us to the second feature that I absolutely love about data classes. Once again, when we printed the object from the data class, we got a useful representation back. One that contained the name, the age and the friends, something that we actually can read as a developer and still understand that person is an object. While with a regular class, we just get the person object at that memory edges, which isn't that useful for us if we care about what it contains. So the string representation in a data class is much more readable. And if we had to create that in our normal class, it would require a lot of work. So here we can type in something such as, done the string, and that's going to return a string. And then we need to return whatever kind of string representation we want to get back. So I mean, if we wanted to copy that, we could type in person, turn that into an F string and start adding the variables, such as name, which will equal the wrapper of name, or actually that has to be self dot name, and so on. We're going to have to do it for each one of these variables. And when we run that, we're going to get probably the same thing back. If we had the energy to do it for all of the arguments, moving on to cool feature number three, which has to do with ordering our data classes with a normal class, it can actually take a lot of work. But with a data class, we have this functionality built in directly and to make it so that we can actually order our data class without having to set up any comparison, done the methods, all we have to do is set order to true. And that will make it orderable. I don't think that's a word, but I'm going to use it. So next, let's create a few other people, such as James type person, which will equal a person named James with the age of 25. And you will have two friends, Bob and Luigi. Then we're going to have Mario of type person, who will equal another person named Mario with the age of 38. And Mario has no friends at all. So we will insert an empty list. Now, first of all, I want to mention that for equality comparisons, you do not need to actually specify this at all. You can just remove this and you can check whether Bob is equal to James, which will obviously return false because these values are not equal to the values in Bob. But if you were to check that Bob was equal to Bob, it would return true. Or if James actually happened to be Bob, Bob and James would be considered the same object, or not the same object, but they would share the same values. So they would be considered the same. But let's change that back to James, because James does not appreciate that. But right now, what we cannot do is check whether Bob is more than James, because we did not set order to be true. So here we can just set it back to true. And now that comparison actually works. So we can check whether Bob is more than James. And if we were to run that, we're going to get false back. And the way it actually does the comparison is by first checking the strings to see whether one string is more than another. If the strings are exactly the same, then it's going to skip this field and move on to the integer to check which one is more or less depending on your comparison. If both of these are the same, it's going to move on to the next one. And that's how it performs the comparisons with these kinds of objects. So for example, if we had two Bob's, Bob one and Bob two. And the second Bob was actually older, you'll see that Bob is going to return false. I mean, younger Bob is not greater than Bob two, which is older Bob. If we do that, it will return true because Bob two is older than Bob. And something else we can do is create a list of people or a list of person, I guess, which will be a list of people anyway, insert Bob, Mario and James. And we can sort these people. We can type in people.sort. Now we can print the people which have just been sorted. And if we were to run this, we will get the people sorted. So it will start with Bob, then we'll get James and finally we'll get Mario. And once again, that's all thanks to this parameter over here. Without it, it's not going to work because we did not define the less than operator. So I guess you can kind of compare this to total ordering in normal classes, except it just takes a lot less setup. Moving on to feature number four, making your data classes immutable. And immutability is actually very important when you don't want something in your class to change at any point during the execution of your script. So to make a data class immutable, all you need to do is set frozen to true. And that just means that if some silly person tries to assign a new value to Bob and change it to James, Python won't allow us to do that because we made a person immutable, which means when we run this, we're going to get an error, a frozen instance error that we cannot assign to field name, because we told Python that we want to make sure that this data class is frozen. And I recommend setting frozen to true the same way you would opt in for a tuple instead of a list. If you know that something should not be changed. In other words, if you know something should remain immutable, Bob might not be the best example because throughout his lifespan, his age might change or the amount of friends he has might change. So maybe frozen wouldn't be good in this example. But if you have data that will never change, use it. And finally, for the final feature, we're going to be talking about computed properties and how easy it is to add them to data classes. So here we'll create a class called rectangle. Everybody loves rectangles. It's going to have a width of type floats. And a height of type float. Now to create a computed property, all we need to do is use the add property decorator and create a method that gives us back whatever computed property we're looking for, such as the area of this rectangle. And that will return to us a float. And all we have to do is the simple math of return self dot width times self dot height. Then maybe we also want a computed property that gives us back the parameter or the parameter. I don't know how actually to say that. Probe 30. I can't spell that either. I'm going downhill from here. And then we can type in death parameter. And that will return to us a float, which will be two times the self dot width plus the self dot height. And finally, for convenience, I'm going to create a method that describes our rectangle. So death, describe, and this will return none because we're only printing data, such as first we want to print self, which is the rectangle with all its data. Then we're going to print the area, which will be self dot area. And we will print the parameter per meter and self dot parameter. And this will be the entire data class. Now let's actually try to use it by creating our rectangles. And the first one will have the creative name of rectangle one, which will be of type rectangle. And that will equal a rectangle with the width set to 10 and the height set to 20. Then we can describe that rectangle. We can type in rectangle one dot describe. And when we run this, we should get our rectangle class back or the representation of it. And the area and the parameter using the computed properties. And we can also access them directly. So we can print, for example, rectangle one dot area. And we will remove the scribe. And what we'll get back is 200. And what's cool about computed properties is that if we were to change the rectangle one dot height to, let's say, 100 and then print rectangle one dot area once again, we're going to get the updated value. It's updating it in lifetime. And we can also change, let's say, the width to 50 and the height to 200 to get a completely different rectangle. Now all we need to do is type in rectangle one dot describe. Now we're going to get the rectangle with these computed properties. But yeah, those were five features that I found to be really cool in data classes. So do let me know what you thought about this video in the comment section down below, whether you want a follow up video. Maybe I can make a video covering more of the features in data classes. Otherwise, feel free to add more information to this video in the comment section down below. It helps a lot of people. And it also helps me when I make more videos. But otherwise, with all that being said, as always, thanks for watching and I'll see you in the next video.