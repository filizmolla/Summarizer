 What really happens behind the scenes when you press that power button to boot up Linux? Today I will give you an inside look. The process starts when you press that power button to turn on your computer. First, a program called a BIOS or UEFI boots up. These are basically pieces of software that gets all the main parts of your computer ready for action. We are talking about the keyboard, screen, hard drives and so on. UEFI is the newer kit on the block. Offering faster boot times and better security features a secure boot compared to the traditional BIOS. One key difference between BIOS and UEFI is in their approach to this storage. BIOS is tied to the master boot record system, which limits this size to two terabyte. UEFI, on the other hand, uses the GWT partition table, removing these size constraints and offering a more flexible and modern solution. Next, the BIOS or UEFI runs a check called a Power On Self Test or Post. This test makes sure all the different hardware bits and pieces are working right before fully turning everything on. It post finds a problem. It will often show an error message on the screen. Finally, if everything checks out with Post, the BIOS or UEFI needs to find and load up the boot loader software. The boot loader is usually set to check the hard drive first, then USB drives or CDs if it doesn't find anything on the hard drive. You can customize this order in the BIOS settings if you want. On a BIOS system, the boot loader code lives in the first little chunk of the hard drive called the master boot record. For UEFI, there's a separate partition that stores files like the .EFI boot loader file. The key jobs for boot loaders are locate the operating system kernel on the disk. Load the kernel into the computer's memory. Start running the kernel code. Now some common boot loaders you might see are Lilo and Grap 2. Lilo or the Linux loader is pretty outdated and rarely used in modern distribution. Grap 2 is the most full feature and widely used today. The key-handle booting multiple operating systems looks nice with graphical or text-based menus and has a bunch of advanced options for power users. So once Grap 2 loads itself up, it inserts the Linux kernel into memory and hands control over to the kernel to finish the startup process. After the boot loader starts the kernel, the kernel takes over the computer's resources and starts initiating all the background processes and services. First, it decompresses itself onto memory, checks the hardware, and loads device drivers and other kernel modules. Next, an initial process called Unit kicks off, which in modern Linux systems is typically system D. System D has replaced older in this system like CIS 5 in NIT and upstart, and is the parent of all other processes on Linux. Unit has set tons of responsibilities to get the system booted and ready to use. It's checking for any remaining hardware that needs drivers loaded. It mongs up all your different file systems and disks so they are accessible. It starts launching all the background services you need like networking, sound, and power management. It handles user logins once you get to the graphical prompt and it loads up your desktop environment with the panels and menus. System D uses target configuration files to decide which mode it should be booting into, something basic like multi-user text only target or the graphical target most of us use daily. Those targets kind of corresponds to the old run levels from past Linux days if you heard of those before. Mostly now you just need to know system D handles initializing everything that needs to launch behind the scenes when starting up Linux. And there you have it, with unpacked the sequence of events that transform your computer hardware into a functioning Linux system when you press the power button. If you like our videos you might like our system design newsletter as well. It covers topics and trends in large-scale system design, trusted by 500,000 readers. Subscribe to blog.bibago.com.